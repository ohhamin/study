### Array, ArrayList, LinkedList

##### 1. Array

array는 선언할 때 크기와 데이터 타입을 지정해야 함(메모리 공간에 사이즈를 정해놓음)

장점 : index가 존재해서 검색이 빠름

단점 : 데이터가 늘어날 때 최대 사이즈를 알 수 없으면 부적합함, 중간에 새로운 값을 넣거나 뺄 때 비효율적(새로운 값을 넣고 index를 밀어내는 과정이 들어감)

##### 2. List

array처럼 크기를 정해주지 않아도 된다 (가득 차면 알아서 크기를 2배 할당하고 복사)

장점 : 데이터를 추가하거나 삭제 가능

단점 : index를 가지고 있기 때문에 중간 데이터 추가 삭제 비효율적

##### 3. LinkedList

노드를 사용하여 다음 노드와 연결될 포인터 위치를 가지고 있음(단일은 뒤의 노드만 가리키고 다중은 앞뒤 모두 가리킴)

장점 : 추가 삭제가 빠름

단점 : index가 없기 때문에 검색이 느림

---

### Stack, Queue

##### 1. Stack

후입선출 방식

원소의 삽입과 삭제가 한쪽 끝에서만 이루어짐 (top)

함수의 콜스택, 연산자 후위표기법, DFS

##### 2. Queue

선입선출 방식

원소의 삽입과 삭제가 양쪽 끝에서 이루어짐 (front, rear)

버퍼, BFS

##### 3. Priority Queue

데이터를 근거로 한 우선순위를 파악하고, 우선순위가 높은 것 부터 나감

구현방법

1. 배열
   데이터 삽입 및 삭제 시 비효율적이고 삽입하기 위해 배열의 모든 데이터 탐색

2. 연결리스트
   삽입과 삭제는 효율적이지만 삽입할 위치를 찾는데 비효율

3. 힙
   완전 이진트리로 최소값이나 최대값이 가장 루트에 있음
   부모의 우선순위는 자식의 우선순위보다 크다.

---

### Tree

Node와 Edge로 이루어진 자료구조

트리에는 사이클이 존재하지 않는다, 루트에서 한 노드로 가는 경로는 유일한 경로뿐이다

##### 트리 순회 방식

1. 전위순회
   루트 > 왼쪽자식 > 오른쪽자식

2. 중위순회
   왼쪽자식 > 루트 > 오른쪽자식

3. 후위순회
   왼쪽자식 > 오른쪽자식 > 루트

4. 레벨순회
   루트부터 계층별로 방문

##### 1. 이진탐색트리(BST)

노드의 왼쪽에는 노드보다 작은 값들, 오른쪽에는 큰 값으로 구성

##### 2. 레드블랙트리

자가 균형 이진 탐색 트리 (나중에 찾아보자)

##### 3. B-트리

이진트리와 다르게 하나의 노드에 많은 정보를 담을 수 있음 (더 많은 자식을 가질 수 있게 일반화)

데이터베이스, 파일시스템에서 주로 사용

##### 4. B+트리

데이터의 빠른 접근을 위한 인덱스 역할만 하는 비단말 노드가 추가로 있음

---

### 해시

데이터를 효율적으로 관리하기 위해 임의의 길이 데이터를 해시 함수를 구현하여 해시 값으로 매핑

데이터가 많아지면 같은 해시 값으로 충돌하는 collision 현상 발생

해결방법

1. 체이닝 : 연결 리스트로 노드를 계속 추가함(메모리 문제 발생)

2. Open Addressing : 해시 함수로 얻은 주소가 아닌 다른 주소에 데이터를 저장할 수 있도록 허용 (다음 주소에 저장)

3. 선형 탐사 : 정해진 고정 폭으로 옮겨 해시값의 중복을 피함

4. 제곱 탐사 : 정해진 고정 폭을 제곱수로 옮겨 해시값의 중복을 피함

##### 맵, 해시맵

map 컨테이너는 이진탐색트리를 사용하다 최근엔 레드블랙트리 사용

key값을 이용해 트리를 탐색하는 방식 (데이터 접근 삽입 삭제는 O(logN)

해시맵은 해시함수를 활용하여 O(1)에 접근 가능

# Array 1

## 알고리즘

* 문제를 해결하기 위한 절차나 방법
* 알고리즘을 표현 : 의사코드(Pseudocode), 순서도
* 좋은 알고리즘 : 정확성, 작업량, 메모리사용량, 단순성, 최적성
* 알고리즘의 작업량을 표현할 때 시간복잡도로 표현한다 (연산의 횟수)

## 배열

* 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조
* 배열의 필요성 : 배열을 사용하면 둘 이상의 변수를 한번에 선언 가능
* 1차원 배열 : Arr = [] Arr = [0] * 10

## 정렬

* 2개 이상의 자료를 특정 기준에 의해 재배열 하는 것
* 키 : 자료를 정렬하는 기준이 되는 특정 값

## bubble sort

* 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식 O(n^2)

  ```python
  for i in range(N-1, 0, -1):
      for j in range(i):
          if arr[j] > arr[j+1]:
              a[j], a[j+1] = a[j+1], a[j]
  ```

## counting sort

* 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘 O(n + k) : n은 리스트길이 k는 정수의 최대값

* data에서 각 항목들의 발생 횟수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열 counts에 저장한다.

* counts의 원소를 누적식으로 저장한다 [1, 3, 1, 1, 2] -> [1, 4, 5, 6, 8]

* counts[1]을 감소시키고 Temp에 1을 삽입함

  ```python
  def Counting_Sort(A, B, k)
  A = [] # 입력 배열
  B = [] # 정렬된 배열
  C = [] # 카운트 배열
  
  C = [0] * (k+1)
  
  for i in range(0, len(A)):
      C[A[i]] += 1
  
  for i in range(1, len(C)):
      C[i] += C[i-1]
   
  for i in range(len(B)-1, -1, -1):
      C[A[i]] -= 1
      B[C[A[i]]] = A[i]
  ```

  

## 완전검색

* 모든 경우의 수를 다 만들어 테스트 - 속도는 느리지만 정확성 높음

* 순열 만들기

  ```python
  for i1 in range(1, 4):
      for i2 in range(1, 4):
          if i2 != i1:
              for i3 in range(1,4):
                  if i3 != i1 and i3 != i2:
                      print(i1, i2, i3)
  ```

  

## 그리디

* 탐욕 알고리즘은 최적해를 구하는 데 사용되는 근시안적인 방법
* 여러 경우 중 그 순간 최적이라고 생각되는 것을 선택해 나가는 방식 (지역적으로 최적이지만 결론적으로 최적이라는 보장은 없음)
* ex) 거스름돈 줄이기 : 거스름돈이 손님에게 줄 액수를 초과하는지 확인하고 초과하면 빼고 아니면 적은 단위 동전을 줌
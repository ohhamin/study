# 객체 지향 프로그래밍

##### 순차적 프로그래밍

필요한 것이 있으면 계속 순서대로 추가해가며 구현하는 방식. 직관적이지만 규모가 커지면 복잡해짐

##### 절차적 프로그래밍

반복될 가능성이 있는 것들을 재사용이 가능한 함수(프로시저)로 만들어 사용

프로그램을 기능 중심으로 바라보는 방식

### 객체 지향 프로그래밍

프로그래밍에서 필요한 데이터들을 자료형과 함수가 같이 존재하는 객체로 구성.

##### 특징

1. 추상화

2. 캡슐화

3. 상속

4. 다형성

##### 추상화

필요로 하는 속성이나 행동을 추출하는 작업

세부적인 사물들의 공통적인 특징을 파악한 후 하나의 집합으로 만들어냄

##### 캡슐화

낮은 결합도를 유지할 수 있도록 설계함

응집도(객체 안의 모듈 간의 요소가 밀접한 관련이 있는 것)를 높히고 결합도(기능을 실행할 때 다른 클래스나 모듈에 얼마나 의존적인가)를 낮춰야 함

정보 은닉을 사용함, 외부에서 접근할 필요가 없으면 private로 접근하지 못하게 제한을 둠

##### 상속

여러 개체들이 지닌 공통된 특성을 하나의 개념이나 법칙으로 성립하는 과정

자식 클래스를 외부로부터 은닉하는 캡슐화의 일종

##### 다형성

서로 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작하는 능력

부모 클래스의 메소드를 자식 클래스가 오버라이딩해서 자신의 역할에 맞게 활용할 수 있음

- 오버라이딩 : 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의해서 사용

- 오버로딩 : 같은 이름의 메서드 여러개를 가지면서 매개변수의 유형과 갯수가 다르도록 하는 기술

##### 객체 지향 설계 원칙(SOLID)

1. SRP(Single Responsibility) - 단일 책임 원칙
   
   클래스는 단 한개의 책임을 가져야 한다.
   
   이를 지키지 않으면, 한 책임의 변경에 의해 다른 책임과 관련된 코드에 영향이 갈 수 있다.
   
   사칙연산 함수를 가진 계산 클래스는 사칙연산 기능만 책임지고 수정한다면 사칙연산에 관련된 문제일 뿐이다.

2. OCP(Open-Closed) - 개방-폐쇄 원칙
   
   확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
   
   기존의 코드는 변경하지 않으면서, 기능을 추가할 수 있도록 설계가 되어야 한다.

3. LSP(Liskov Substitution) - 리스코프 치환 법칙
   
   상위 타입의 객체를 하위 타입의 객체로 치환해도, 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
   
   상속 관계가 아닌 클래스들을 상속 관계로 설정하면, 이 원칙이 위배된다.

4. ISP(Interface Segregation) - 인터페이스 분리 원칙
   
   인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
   
   각 클라이언트가 필요로 하는 인터페이스들을 분리함으로써, 각 클라이언트가 사용하지 않는 인터페이스에 변경이 발생하더라도 영향을 받지 않도록 만들어야 한다.

5. DIP(Dependency Inversion) - 의존 역전 원칙
   
   고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.
   
   저수준 모듈이 변경되도 고수준 모듈은 변경할 필요가 없다.

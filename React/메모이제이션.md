# 메모이제이션

메모이제이션이란 함수 호출의 결과를 캐싱하고 동일한 입력이 다시 발생할 때 불필요하게 다시 계산하는 대신 캐싱된 결과를 반환하는 기술이다.

React에서는 useCallback, useMemo와 같은 훅을 사용함.

하지만 메모리에 특정한 값을 저장하는 것이기 때문에, 남용하면 오히려 성능을 저하시킬 수 있다.

### 함수형 프로그래밍과 메모이제이션

메모이제이션은 순수 함수의 실행을 최적화하기 위해 함수형 프로그래밍에서 자주 사용됨.

(참고 : [함수형 프로그래밍 이란?](../소프트웨어공학/함수형프로그래밍.md))

함수형 프로그래밍은 동일한 입력에 대해 동일한 출력을 생성하고 side effect가 없는 순수함수의 사용을 강조한다.

그리고 메모이제이션은 함수를 다시 평가하는 대신 캐싱된 결과를 반환하여 함수의 성능을 향상시킨다.

따라서 메모이제이션은 순수 함수 호출을 최적화하고 중복 계산을 줄이며 성능을 향상시키는 방법을 제공함으로써 함수형 프로그래밍 패러다임을 보완하는 기술이다.

### 함수형 프로그래밍 언어에서 메모이제이션 구현하기

```js
function memoize(func) {  
  const cache = {};

  return function(...args) {
    const key = JSON.stringify(args);

    if (cache[key]) {
      console.log("Fetching result from cache...");
      return cache[key];
    }

    console.log("Computing result...");
    const result = func(...args);
    cache[key] = result;
    return result;
  };
}

function sum(a, b) {  
  console.log("Executing sum function...");
  return a + b;
}

const memoizedSum = memoize(sum);

console.log(memoizedSum(2, 3)); // Executing sum function... (result: 5)  
console.log(memoizedSum(2, 3)); // Fetching result from cache... (result: 5)  
console.log(memoizedSum(4, 5)); // Executing sum function... (result: 9)  
console.log(memoizedSum(4, 5)); // Fetching result from cache... (result: 9)  
```

memoize 함수는 함수를 인수로 받아 메모이제이션 로직을 캡슐화하는 클로저 함수를 반환한다.

memoizedSum 함수가 파라미터와 함께 호출되면 클로저 함수는 해당 파라미터에 대해 이미 cache에 저장된 결과가 있는지 확인한다. cache에 저장된 결과가 있다면 함수를 다시 계산하지 않고 저장된 결과를 반환한다. 만약 저장된 결과가 없다면 함수를 실행하고 그 결과를 cache에 저장한다.

### React에서의 메모이제이션 사용

React에서는 memo, useMemo, useCallback 등을 통해 메모이제이션을 사용할 수 있다.

### 메모이제이션과 성능

메모이제이션을 사용하면 무조건 성능이 좋아질까?

일반 함수는 랜더링될 때 기존 함수는 가비지 컬렉션되고 새로운 함수가 생성되는 단순한 작업을 한다. 하지만 useCallback을 사용하면 의존성 확인을 위해 종속된 값들의 참조를 가지고 있어야 하며, 매 랜더링마다 해당 값들을 비교해야한다. 함수 정의를 위해 배열을 할당해야하고, 메모리에 저장된다.

따라서 무분별하게 사용하면 오히려 성능을 떨어뜨리는 결과를 가져올 수 있다.

### 메모이제이션이 필요한 경우

#### 비용이 많이 드는 계산

시간과 리소스가 많이 드는 함수나 계산이 있는 경우 메모이제이션을 사용하여 결과를 캐싱하여 다시 계산하지 않도록 할 수 있다.

연산, 처리량이 매우 많아서 랜더링의 문제가 되는 경우 메모이제이션으로 재랜더링시 비용을 절감할 수 있다.

사용자의 입력 값이 map과 filter를 사용했을 때와 같이 랜더링 이후로도 참조적으로 동일할 가능성이 높은 경우 useMemo를 사용하는 것이 좋다.

#### 자식 컴포넌트에 함수를 props로 넘길 때

부모로부터 동일한 props를 수신하고 동일한 입력에 대해 동일한 출력을 생성하는 컴포넌트의 경우, props가 변경되지 않을 때 재랜더링 되는 것을 방지할 수 있다.

자식 컴포넌트로 전달되거나 이벤트 처리기로 사용되는 콜백 함수가 있는 경우, 콜백 함수를 메모이제이션해 해당 자식 컴포넌트의 불필요한 재랜더링을 방지할 수 있다. 이렇게 하면 콜백에 의존하는 자식 컴포넌트의 불필요한 재랜더링을 방지하면서 랜더링 간에 동일한 함수 참조가 사용된다.

#### 다른 훅의 의존성에 사용될 때

useEffect의 의존성 목록에 비용이 많이 드는 계산이나 랜더링 간에 변경할 필요가 없는 개체가 있는 경우 메모이제이션을 사용할 수 있다.

특히 콜백 함수 등을 의존성에 포함해야 하는 경우 메모이제이션을 사용하면 콜백 함수 참조가 안정적으로 유지되고, 의존성이 변경될 때 불필요한 Effect가 트리거되지 않는다.

### 메모이제이션이 필요 없는 경우

#### 자주 다시 랜더링되는 컴포넌트 (React.memo의 경우)

컴포넌트의 props가 자주 변경되는 경우 이를 메모이제이션 하는 것이 비생산적일 수 있다.

props 변경 사항을 확인하고 메모이제이션한 결과를 다시 계산하는 오버헤드가 이점보다 클 수 있기 때문이다.

#### 작은 컴포넌트

빠르게 랜더링되는 작고 간단한 컴포넌트의 경우 메모이제이션이 상당한 성능 향상을 제공하지 않을 수 있다. 일반적으로 메모이제이션은 큰 컴포넌트나 계산 비용이 많이 드는 컴포넌트에 더 유용하다.

#### 기본적이거나 빠른 작업

기본 산술, 문자열 연결, 배열 조작과 같은 간단한 작업은 일반적으로 빠르고 저렴하기 때문에 메모이제이션이 필요하지 않다.

연산이 복잡하지 않은 함수에 메모이제이션을 사용하는 것은 메모리 낭비이므로, 간단한 함수에는 메모이제이션을 사용하지 않는 것이 좋다.

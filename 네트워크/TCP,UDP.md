# TCP, UDP

### TCP와 UDP의 차이

##### TCP (Transmission Control Protocol)

연결지향형, 신뢰성

##### UDP (**User Datagram Protocol** 또는 Universal Datagram Protocol)

비연결지향형, 비신뢰성, 실시간

## UDP

전송 방식이 너무 단순해서 서비스의 신뢰성이 낮고, 데이터그램 도착 순서가 바뀌거나 중복되거나 심지어 누락

사용 : DNS 서버(도메인 -> IP), tftp서버(파일공유) , 실시간 스트리밍

DNS가 UDP 사용하는 이유

- Request의 양이 작음 -> UDP Request에 담길 수 있다.

- 3 way handshaking으로 연결을 유지할 필요가 없다. (오버헤드 발생)

- Request에 대한 손실은 Application Layer에서 제어가 가능하다.

- DNS : port 53번

- But, TCP를 사용할 때가 있다! 크기가 512(UDP 제한)이 넘을 때, TCP를 사용해야한다.

## TCP

인터넷에 연결된 컴퓨터에서 실행되는 프로그램 간에 통신을 **안정적으로, 순서대로, 에러없이** 교환할 수 있게 한다.

##### 연결과정

###### 3 way handshack - 연결 성립

- 클라이언트가 서버에게 요청 패킷을 보냄

- 서버가 클라이언트의 요청을 받아들이는 패킷을 보냄

- 클라이언트가 이를 수락하는 패킷을 보냄

###### 4 way handshake - 연결 해제

- 클라이언트는 서버에게 연결을 종료한다는 FIN 플래그를 보낸다.

- 서버는 FIN을 받고, 확인했다는 ACK를 클라이언트에게 보낸다. (이때 모든 데이터를 보내기 위해 CLOSE_WAIT 상태가 된다)

- 데이터를 모두 보냈다면, 연결이 종료되었다는 FIN 플래그를 클라이언트에게 보낸다.

- 클라이언트는 FIN을 받고, 확인했다는 ACK를 서버에게 보낸다. (아직 서버로부터 받지 못한 데이터가 있을 수 있으므로 TIME_WAIT을 통해 기다린다.)
  
  - 서버는 ACK를 받은 이후 소켓을 닫는다 (Closed)
  
  - TIME_WAIT 시간이 끝나면 클라이언트도 닫는다 (Closed)

## 흐름제어, 혼잡제어

##### 흐름제어

수신측이 송신측보다 데이터 처리 속도가 빠르면 문제없지만, 송신측의 속도가 빠를 경우 문제가 생긴다.

###### 해결방법

1. Stop and Wait : 매번 전송한 패킷에 대해 확인 응답을 받아야만 그 다음 패킷을 전송하는 방법

2. Sliding Window (Go Back N ARQ) : 먼저 윈도우에 포함되는 모든 패킷을 전송하고, 그 패킷들의 전달이 확인되는대로 이 윈도우를 옆으로 옮김으로써 그 다음 패킷들을 전송

##### 혼잡제어

송신측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달된다. 만약 한 라우터에 데이터가 몰릴 경우, 자신에게 온 데이터를 모두 처리할 수 없게 된다. 이런 경우 호스트들은 또 다시 재전송을 하게되고 결국 혼잡만 가중시켜 오버플로우나 데이터 손실을 발생시키게 된다. 따라서 이러한 네트워크의 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송속도를 강제로 줄이게 되는데, 이러한 작업을 혼잡제어라고 한다.

###### 해결방법

1. AIMD(Additive Increase / Multiplicative Decrease) : 처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 window 크기(단위 시간 내에 보내는 패킷의 수)를 1씩 증가시켜가며 전송하는 방법

2. Slow Start (느린 시작) : Slow Start 방식은 AIMD와 마찬가지로 패킷을 하나씩 보내면서 시작하고, 패킷이 문제없이 도착하면 각각의 ACK 패킷마다 window size를 1씩 늘려준다. 즉, 한 주기가 지나면 window size가 2배로 된다.

3. Fast Retransmit (빠른 재전송) : 패킷을 받는 쪽에서 먼저 도착해야할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK 패킷을 보내게 된다.

4. Fast Recovery (빠른 회복) : 혼잡한 상태가 되면 window size를 1로 줄이지 않고 반으로 줄이고 선형증가시키는 방법이다. 이 정책까지 적용하면 혼잡 상황을 한번 겪고 나서부터는 순수한 AIMD 방식으로 동작하게 된다.


